"""
üåø COPY-PASTE THIS INTO GOOGLE COLAB
==================================================
Each comment block = One Colab Cell
Run cells in order (1 ‚Üí 2 ‚Üí 3 ‚Üí 4 ‚Üí 5)
"""

# ===========================================
# üì¶ CELL 1: Mount Drive & Install
# ===========================================
from google.colab import drive
drive.mount('/content/drive', force_remount=True)

!pip install flask flask-cors pyngrok pillow torch torchvision -q
!pip install git+https://github.com/openai/CLIP.git -q
print("‚úÖ Setup complete!")


# ===========================================
# ü§ñ CELL 2: Load CLIP & Model
# ===========================================
import torch
import clip
from torch import nn
import os

device = "cuda" if torch.cuda.is_available() else "cpu"
print(f"üîß Device: {device}")

# Load CLIP
model_clip, preprocess = clip.load("ViT-L/14", device=device, jit=False)
model_clip.eval()
print("‚úÖ CLIP loaded")

# Define Classifier
class Classifier(nn.Module):
    def __init__(self, in_dim, num_classes):
        super().__init__()
        self.net = nn.Sequential(
            nn.Linear(in_dim, 512), nn.BatchNorm1d(512), nn.ReLU(), nn.Dropout(0.3),
            nn.Linear(512, 256), nn.ReLU(), nn.Dropout(0.2),
            nn.Linear(256, num_classes)
        )
    def forward(self, x): return self.net(x)

# Load your trained model
MODEL_PATH = '/content/drive/MyDrive/mvpdr_highacc_model.pth'
checkpoint = torch.load(MODEL_PATH, map_location=device)
classes = checkpoint['classes']
model_clf = Classifier(768, len(classes)).to(device)
model_clf.load_state_dict(checkpoint['model_state'])
model_clf.eval()
print(f"‚úÖ Model loaded! {len(classes)} classes")


# ===========================================
# üß† CELL 3: Prediction Function
# ===========================================
from PIL import Image
import io
import torch.nn.functional as F

def predict_disease(image_bytes):
    try:
        img = Image.open(io.BytesIO(image_bytes)).convert("RGB")
        img_tensor = preprocess(img).unsqueeze(0).to(device)
        
        with torch.no_grad():
            feat = model_clip.encode_image(img_tensor)
            feat = feat / feat.norm(dim=-1, keepdim=True)
            logits = model_clf(feat.float())
            probs = F.softmax(logits, dim=-1)[0]
            
            top_probs, top_indices = torch.topk(probs, min(3, len(classes)))
            top_predictions = [
                {'class_name': classes[idx.item()], 'confidence': prob.item()}
                for prob, idx in zip(top_probs, top_indices)
            ]
            
            pred_idx = probs.argmax().item()
            return {
                'success': True,
                'disease': classes[pred_idx],
                'class_name': classes[pred_idx],
                'confidence': probs[pred_idx].item(),
                'top_predictions': top_predictions
            }
    except Exception as e:
        return {'success': False, 'error': str(e)}

print("‚úÖ Prediction function ready!")


# ===========================================
# üåê CELL 4: Create Flask API
# ===========================================
from flask import Flask, request, jsonify
from flask_cors import CORS

app = Flask(__name__)
CORS(app)

@app.route('/', methods=['GET'])
def home():
    return jsonify({'status': 'running', 'model': 'CLIP ViT-L/14', 'classes': len(classes), 'device': device})

@app.route('/diagnose', methods=['POST'])
def diagnose():
    try:
        if 'image' not in request.files:
            return jsonify({'error': 'No image'}), 400
        
        image_file = request.files['image']
        crop = request.form.get('crop', 'unknown')
        image_bytes = image_file.read()
        
        result = predict_disease(image_bytes)
        
        if result['success']:
            print(f"‚úÖ {result['disease']} ({result['confidence']*100:.1f}%)")
            return jsonify(result), 200
        else:
            return jsonify(result), 500
    except Exception as e:
        return jsonify({'error': str(e), 'success': False}), 500

print("‚úÖ Flask API ready!")


# ===========================================
# üöÄ CELL 5: Start Server (EDIT TOKEN!)
# ===========================================
from pyngrok import ngrok

# üëá PASTE YOUR NGROK TOKEN HERE (get from https://dashboard.ngrok.com/get-started/your-authtoken)
NGROK_TOKEN = "YOUR_TOKEN_HERE"

if NGROK_TOKEN == "YOUR_TOKEN_HERE":
    print("‚ö†Ô∏è  ERROR: Please set your ngrok token above!")
    print("Get it from: https://dashboard.ngrok.com/get-started/your-authtoken")
else:
    ngrok.set_auth_token(NGROK_TOKEN)
    ngrok.kill()
    
    public_url = ngrok.connect(5000)
    
    print("\n" + "="*60)
    print(f"üåê YOUR API URL: {public_url}/diagnose")
    print("="*60)
    print(f"\nüìã Copy this URL to backend/disease_detection/image_views.py:")
    print(f'   COLAB_IMAGE_API_URL = "{public_url}/diagnose"')
    print("\n" + "="*60 + "\n")
    
    # Start server (keep this cell running!)
    app.run(port=5000)


# ===========================================
# ‚úÖ DONE! Keep this notebook running.
# When disconnected, just re-run Cell 5.
# ===========================================

